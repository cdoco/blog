<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Life is strange"><title>Debugging PHP Extensions | C &amp; Fish</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Debugging PHP Extensions</h1><a id="logo" href="/.">C &amp; Fish</a><p class="description">Life is strange</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> Accueil</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Debugging PHP Extensions</h1><div class="post-meta">Feb 23, 2016<span> | </span><span class="category"><a href="/categories/php扩展/">php扩展</a></span></div><div class="post-content"><p>GDB, or the GNU Project Debugger, allows you to debug a program while it is executing. GDB can start a program, stop it on specified conditions, examine the execution environment when the program is stopped and allow you to change things inside the running program itself.</p>
<p><a href="https://sourceware.org/gdb/current/onlinedocs/gdb/" target="_blank" rel="external">GDB Reference Documentation</a></p>
<h3 id="Configuring-GDB"><a href="#Configuring-GDB" class="headerlink" title="Configuring GDB"></a>Configuring GDB</h3><p>Let’s get started by changing to the php-src directory</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> ~/php-src</div></pre></td></tr></table></figure>
<p>The .gdbinit script is provided with the PHP source distribution. By copying this file to the home directory, gdb will always load this file when it starts.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ copy .gdbinit ~</div></pre></td></tr></table></figure>
<p>Alternatively you can load the script into gdb at runtime:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) <span class="built_in">source</span> /home/vagrant/php-src/.gdbinit</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>The .gdbinit script provides a number of commands within gdb that are helpful when debugging extensions.</p>
<p>To view the available commands once the .gdbinit script is loaded provided try the following:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) <span class="built_in">help</span> user-defined</div></pre></td></tr></table></figure>
<p>Of particular interest is zbacktrace which enables one to backtrace from C to PHP.</p>
<h3 id="Debugging-a-PCRE-extension"><a href="#Debugging-a-PCRE-extension" class="headerlink" title="Debugging a PCRE extension"></a>Debugging a PCRE extension</h3><p>To familiarise ourselves with GDB and its commands available for debugging we will step through a PHP PCRE extension test.</p>
<h4 id="PHP-Tests-Wrapper"><a href="#PHP-Tests-Wrapper" class="headerlink" title="PHP Tests Wrapper"></a>PHP Tests Wrapper</h4><p>The run-tests.php script locates test files and then creates a unique shell script to execute each one in a pristine context. To avoid the complexity and overhead of dealing with GDB and fork/exec, we will run our test directly and bypass the run-tests.php script.</p>
<h4 id="Loading-GDB"><a href="#Loading-GDB" class="headerlink" title="Loading GDB"></a>Loading GDB</h4><p>Now let’s load gdb and tell it we intend to run the phpt test file by executing the PHP CLI binary with an argument to its location:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ gdb --args sapi/cli/php ext/pcre/tests/preg_match_basic.phpt</div></pre></td></tr></table></figure>
<h4 id="PHP-Function-calls"><a href="#PHP-Function-calls" class="headerlink" title="PHP Function calls"></a>PHP Function calls</h4><p>The PHP function we intend to examine is preg_match() and is defined in the ext/pcre/php_pcre.c file as a static PHP_FUNCTION wrapper around another static function php_do_pcre_match.</p>
<p>Our test file, ext/pcre/tests/preg_match_basic.phpt evaluates a number of regular expressions against a string and extracts matches into a variable. The .phpt file defines a PHP script to run as input and the corresponding output data that it expects to see from a successful test.</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$string = <span class="string">'Hello, world. [*], this is \ a string'</span>;</div><div class="line">var_dump(preg_match(<span class="string">'/^[hH]ello,\s/'</span>, $string, $match1)); <span class="comment">//finds "Hello, "</span></div><div class="line">var_dump($match1);</div></pre></td></tr></table></figure>
<p>Running the above should produce:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">int(<span class="number">1</span>)</div><div class="line"><span class="keyword">array</span>(<span class="number">1</span>) &#123;</div><div class="line">  [<span class="number">0</span>]=&gt;</div><div class="line">  string(<span class="number">7</span>) <span class="string">"Hello, "</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Where int(1) signifies preg_match returning true for a match, with an array(1) of matched strings, in this case there is only one match, “Hello, “.</p>
<p>Knowing that php_do_pcre_match is called, let’s tell gdb we would like to break on invocation of php_do_pcre_match and then run the test.</p>
<p>TODO: more info on breakpoint formats.</p>
<h4 id="Setting-Breakpoints"><a href="#Setting-Breakpoints" class="headerlink" title="Setting Breakpoints"></a>Setting Breakpoints</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(gdb) <span class="built_in">break</span> php_do_pcre_match</div><div class="line">(gdb) run</div></pre></td></tr></table></figure>
<p>After a few moments, you should see something similar to:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Breakpoint 1, php_do_pcre_match (execute_data=0x7ffff0214260, return_value=0x7ffff0214100,</div><div class="line">    global=0)</div><div class="line">  at /home/vagrant/php-src/ext/pcre/php_pcre.c:549</div></pre></td></tr></table></figure>
<p>Let’s use the zbacktrace command to find out where we came from.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(gdb) zbacktrace</div><div class="line">[0x7ffff0214260] preg_match(<span class="string">"/^[hH]ello,\s/"</span>, <span class="string">"Hello,\40world.\40[*],\40this\40is\40\\40</span></div><div class="line"><span class="string">    a\40string"</span>, reference) [internal <span class="keyword">function</span>]</div><div class="line">[0x7ffff0214030] (main) /home/vagrant/php-src/ext/pcre/tests/preg_match_basic.phpt:10</div></pre></td></tr></table></figure>
<p>The above output shows that we are inside the the function that generates the output that will be used as a comparison for the first assertion of our unit test. The first unit test in the preg_match_basic.phpt file tries to find matches based on the regex “/^[hH]ello,\s/“ against our subject string “Hello, world. [4], this is \ a string”.</p>
<h4 id="Program-Execution-Flow"><a href="#Program-Execution-Flow" class="headerlink" title="Program Execution Flow"></a>Program Execution Flow</h4><p>Running next allows us to move line by line through the execution of the original source code. Enter next a few times until you reach a function invocation that looks like this:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(gdb) next</div><div class="line">    php_pcre_match_impl(pce, subject-&gt;val, (int)subject-&gt;len, return_value, subpats, ...</div></pre></td></tr></table></figure>
<p>In GDB, we can step inside any function call. The ‘next’ command by default steps over functions where as ‘step’ allows us to follow the execution path.</p>
<p>Let’s step inside! For function calls that span multiple lines in the source file, you may have to call step a few times.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(gdb) step</div><div class="line">...</div><div class="line">(gdb) step</div><div class="line">php_pcre_match_impl (pce=0x1a98b70, subject=0x7ffff02028b8 <span class="string">"Hello, world. [*], this is \\</span></div><div class="line"><span class="string">    a string"</span>, subject_len=37, return_value=0x7ffff0214100, subpats=0x7ffff02010e8, global=0,</div><div class="line">    use_flags=0, flags=0, start_offset=0)</div><div class="line">  at /home/vagrant/php-src/ext/pcre/php_pcre.c:585</div></pre></td></tr></table></figure>
<p>Now we are inside the lowest level of the extension that wraps about the PCRE library. Looking at the source for php_pcre.c, we see that php_do_pcre_match calls another function php_pcre_match_impl after parsing the arguments from the Zend VM. We know the string that’s the subject for evaluation, let’s see if we can use the argument subject to php_pcre_match_impl to catch it.</p>
<p>In GDB a break can take a conditional argument. Knowing that a string starting with the character ‘H’ is the subject for our unit tests, let’s try and break on that condition. To do so we’ll kill the current running program, delete the existing breakpoint and create a new conditional one.</p>
<h4 id="Stopping-Execution-and-Breakpoints"><a href="#Stopping-Execution-and-Breakpoints" class="headerlink" title="Stopping Execution and Breakpoints"></a>Stopping Execution and Breakpoints</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(gdb) <span class="built_in">kill</span></div><div class="line">Kill the program being debugged? (y or n) y</div></pre></td></tr></table></figure>
<p>Delete the existing breakpoint:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) delete 1</div></pre></td></tr></table></figure>
<p>Now let’s set a conditional breakpoint in the lower level function we stepped into before:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(gdb) <span class="built_in">break</span> php_pcre_match_impl <span class="keyword">if</span> subject[0] == <span class="string">'H'</span></div><div class="line">(gdb) run</div></pre></td></tr></table></figure>
<p>Success!</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Breakpoint 2, php_pcre_match_impl (pce=0x1a98b70, subject=0x7ffff02028b8 <span class="string">"Hello, world. [*],</span></div><div class="line"><span class="string">    this is \\ a string"</span>, subject_len=37, return_value=0x7ffff0214100, subpats=0x7ffff02010e8,</div><div class="line">    global=0, use_flags=0, flags=0, start_offset=0)</div><div class="line">  at /home/vagrant/php-src/ext/pcre/php_pcre.c:585</div></pre></td></tr></table></figure>
<p>Let’s have a look at what’s happening inside this function and start execution line by line:</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(gdb) info args</div><div class="line">...</div><div class="line">(gdb) info <span class="built_in">local</span></div><div class="line">...</div><div class="line">(gdb) next</div><div class="line">...</div></pre></td></tr></table></figure>
<p>The args output clearly shows the string we were looking for. Local shows the variables in scope for the current function. Now we can start moving through the code and find out how php_pcre_match_impl works. Looking at the source, we can see a call to a library function pcre_exec at line 688. Let’s break there.</p>
<p>First we create a new breakpoint, continue execution, and then step inside the pcre_exec call.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(gdb) <span class="built_in">break</span> 688</div><div class="line">(gdb) <span class="built_in">continue</span></div><div class="line">(gdb) step</div></pre></td></tr></table></figure>
<p>Once we’re done debugging the pcre_exec call, to return from the current function we can use ‘finish’ and look at the results being passed back through to the extension.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(gdb) finish</div></pre></td></tr></table></figure>
<p>Now we’re back from the call to count = pcre_exec(…), let’s look at the result.</p>
<h4 id="Exploring-Variables-and-Types"><a href="#Exploring-Variables-and-Types" class="headerlink" title="Exploring Variables and Types"></a>Exploring Variables and Types</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Run till <span class="built_in">exit</span> from <span class="comment">#0  php_pcre_exec (argument_re=0x1a98a00, extra_data=0x1a98a80,</span></div><div class="line">    subject=0x7ffff02028b8 <span class="string">"Hello, world. [*], this is \\ a string"</span>, length=37,</div><div class="line">    start_offset=0, options=0, offsets=0x7fffffffa8c0, offsetcount=3)</div><div class="line">  at /home/vagrant/php-src/ext/pcre/pcrelib/pcre_exec.c:6355</div><div class="line"></div><div class="line">0x00000000005860f5 <span class="keyword">in</span> php_pcre_match_impl (pce=0x1a98b70, subject=0x7ffff02028b8 <span class="string">"Hello,</span></div><div class="line"><span class="string">    world. [*], this is \\ a string"</span>, subject_len=37, return_value=0x7ffff0214100,</div><div class="line">    subpats=0x7ffff02010e8, global=0, use_flags=0, flags=0, start_offset=0)</div><div class="line">  at /home/vagrant/php-src/ext/pcre/php_pcre.c:688</div><div class="line"></div><div class="line">688  count = pcre_exec(pce-&gt;re, extra, subject, (int)subject_len, (int)start_offset,</div><div class="line">Value returned is <span class="variable">$1</span> = 1</div></pre></td></tr></table></figure>
<p>Excellent, so our library function pcre_exec correctly found 1 match for the regular expression against the subject and returned the result to the local variable count in the php_pcre_match_impl function.</p>
<p>Let’s learn how to unpack and inspect some internal zend engine data types to look at the results being returned back to PHP. First, let’s finish the current php_pcre_match_impl function and get back to our entry point, php_do_pcre_match.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(gdb) finish</div><div class="line">Run till <span class="built_in">exit</span> from <span class="comment">#0  php_pcre_match_impl (pce=0x1a98b70, subject=0x7ffff02028b8 "Hello,</span></div><div class="line">    world. [*], this is \\ a string<span class="string">", subject_len=37, return_value=0x7ffff0214100,</span></div><div class="line"><span class="string">    subpats=0x7ffff02010e8, global=0, use_flags=0, flags=0, start_offset=0)</span></div><div class="line"><span class="string">  at /home/vagrant/php-src/ext/pcre/php_pcre.c:585</span></div><div class="line"><span class="string">0x0000000000585a5c in php_do_pcre_match (execute_data=0x7ffff0214260,</span></div><div class="line"><span class="string">    return_value=0x7ffff0214100, global=0)</span></div><div class="line"><span class="string">  at /home/vagrant/php-src/ext/pcre/php_pcre.c:574</span></div></pre></td></tr></table></figure>
<p>The above message indicates we’ve returned back to php_do_pcre_match, let’s investigate the local variables available to us.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(gdb) info locals</div><div class="line">regex = 0x7ffff0264dc0</div><div class="line">subject = 0x7ffff02028a0</div><div class="line">pce = 0x1a98b70</div><div class="line">subpats = 0x7ffff02010e8</div><div class="line">flags = 0</div><div class="line">start_offset = 0</div><div class="line">__PRETTY_FUNCTION__ = <span class="string">"php_do_pcre_match"</span></div></pre></td></tr></table></figure>
<p>We know that the 3rd argument of preg_match takes a variable to return an array of the matches as subpatterns. The results are held in the subpats* pointer, let’s find out more about it.</p>
<p>First, let’s find out the type of subpats using the ptype command.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(gdb) ptype subpats</div><div class="line">type = struct _zval_struct &#123;</div><div class="line">    zend_value value;</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>...&#125; v;</div><div class="line">        <span class="keyword">uint32_t</span> type_info;</div><div class="line">    &#125; u1;</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="keyword">uint32_t</span> var_flags;</div><div class="line">        <span class="keyword">uint32_t</span> next;</div><div class="line">        <span class="keyword">uint32_t</span> cache_slot;</div><div class="line">        <span class="keyword">uint32_t</span> lineno;</div><div class="line">        <span class="keyword">uint32_t</span> num_args;</div><div class="line">        <span class="keyword">uint32_t</span> fe_pos;</div><div class="line">        <span class="keyword">uint32_t</span> fe_iter_idx;</div><div class="line">    &#125; u2;</div><div class="line">&#125; *</div></pre></td></tr></table></figure>
<p>The above output indicates that subpats is a pointer to a _zval_struct that holds a zend_value type named value. What’s a zend_value? It’s the generic data type PHP uses internally for most of its scalars/primitives.</p>
<p>We can find out more information about zend_value using the same ptype command. Note, that we can query the type directly or a variable of that type. I.e. ptype zend_value would return the same information.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">(gdb) ptype subpats-&gt;value</div><div class="line">type = <span class="keyword">union</span> _zend_value &#123;</div><div class="line">    zend_long lval;</div><div class="line">    <span class="keyword">double</span> dval;</div><div class="line">    zend_refcounted *counted;</div><div class="line">    zend_string *str;</div><div class="line">    zend_array *arr;</div><div class="line">    zend_object *obj;</div><div class="line">    zend_resource *res;</div><div class="line">    zend_reference *ref;</div><div class="line">    zend_ast_ref *ast;</div><div class="line">    zval *zv;</div><div class="line">    <span class="keyword">void</span> *ptr;</div><div class="line">    zend_class_entry *ce;</div><div class="line">    zend_function *func;</div><div class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">        <span class="keyword">uint32_t</span> w1;</div><div class="line">        <span class="keyword">uint32_t</span> w2;</div><div class="line">    &#125; ww;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>The above exposes the generic data structure PHP uses internally for holding values. We know the return type is an array, so we expect zend_array *arr to hold our information.</p>
<p>Next, we print the type of a zend_array.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">(gdb) ptype subpats-&gt;value-&gt;arr</div><div class="line">type = struct _zend_array &#123;</div><div class="line">    zend_refcounted gc;</div><div class="line">    <span class="keyword">union</span> &#123;</div><div class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span>...&#125; v;</div><div class="line">        <span class="keyword">uint32_t</span> flags;</div><div class="line">    &#125; u;</div><div class="line">    <span class="keyword">uint32_t</span> nTableSize;</div><div class="line">    <span class="keyword">uint32_t</span> nTableMask;</div><div class="line">    <span class="keyword">uint32_t</span> nNumUsed;</div><div class="line">    <span class="keyword">uint32_t</span> nNumOfElements;</div><div class="line">    <span class="keyword">uint32_t</span> nInternalPointer;</div><div class="line">    zend_long nNextFreeElement;</div><div class="line">    Bucket *arData;</div><div class="line">    <span class="keyword">uint32_t</span> *arHash;</div><div class="line">    <span class="keyword">dtor_func_t</span> pDestructor;</div><div class="line">&#125; *</div></pre></td></tr></table></figure>
<p>Aha! PHP uses a ‘bucket’ concept to store it’s array data. We expected 1 match from our unit test on the word ‘Hello’, let’s find out how many items are in the subpats array.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(gdb) <span class="built_in">print</span> subpats-&gt;value-&gt;arr-&gt;nNumOfElements</div><div class="line"><span class="variable">$2</span> = 1</div></pre></td></tr></table></figure>
<p>So there is one element in our array, presumably held in the arData pointer to a Bucket. Let’s find out more about the structure of a Bucket type by querying the type directly instead of the arData pointer.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(gdb) ptype Bucket</div><div class="line">type = struct _Bucket &#123;</div><div class="line">    zval val;</div><div class="line">    zend_ulong h;</div><div class="line">    zend_string *key;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>So a Bucket consists of a val and a key. A zval has a value that’s a zend_value, and we know the array result should contain a string for the subpattern match. Therefore subpats-&gt;value-&gt;arr-&gt;arData-&gt;val-&gt;value-&gt;str should be a zend_string with a length property and a char val.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(gdb) <span class="built_in">print</span> subpats-&gt;value-&gt;arr-&gt;arData-&gt;val-&gt;value-&gt;str-&gt;len</div><div class="line"><span class="variable">$3</span> = 7</div></pre></td></tr></table></figure>
<p>So our result has a length of 7. Let’s look at the result itself. GDB print command (or p or x) has a number of additional and useful features. First, we can specify the output format, and for arrays we can pass our length using the @ operator.</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(gdb) <span class="built_in">print</span>/c subpats-&gt;value-&gt;arr-&gt;arData-&gt;val-&gt;value-&gt;str-&gt;val@7</div><div class="line"><span class="variable">$4</span> = &#123;&#123;72 <span class="string">'H'</span>&#125;, &#123;101 <span class="string">'e'</span>&#125;, &#123;108 <span class="string">'l'</span>&#125;, &#123;108 <span class="string">'l'</span>&#125;, &#123;111 <span class="string">'o'</span>&#125;, &#123;44 <span class="string">','</span>&#125;, &#123;32 <span class="string">' '</span>&#125;&#125;</div></pre></td></tr></table></figure>
<p>You can also use the x command to inspect variables/memory</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(gdb) x subpats-&gt;value-&gt;arr-&gt;arData-&gt;val-&gt;value-&gt;str-&gt;val</div><div class="line">0x7ffff0258c58: <span class="string">"Hello, "</span></div></pre></td></tr></table></figure>
<p>And there it is, our match “Hello, “ being returned to PHP.</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>What have we learnt? Zval’s are just a struct that contain’s a zend_value, and a zend_value is a generic data type that can represent any PHP value. A PHP array consists of a “bucket” structure (among other things), which is ultimately just a reference to another zval (i.e. any type).</p>
<p>We have a zval -&gt; zend_value -&gt; array -&gt; bucket -&gt; zval -&gt; zend_value -&gt; str where our subpattern match is held.</p>
<p>As a final note, it’s important to know that all PHP functions are exposed to GDB through a symbol table that prefixes them with zif_. For example, we could have chosen to break on zif_preg_match insterad of php_do_pcre_match initially. This would have broken at the static function wrapper around php_do_pcre<em>match. Global object functions are exposed under the zim</em> prefix with the pattern zim_classname_methodname.</p>
<p>Happy debugging!</p>
</div><div class="tags"><a href="/tags/gdb/">gdb</a><a href="/tags/php/">php</a><a href="/tags/php扩展/">php扩展</a></div><div class="post-nav"><a href="/2016/03/10/php-ext-class/" class="pre">PHP扩展实现类</a><a href="/2016/02/22/docker-basics/" class="next">docker常用命令</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="https://cdoco.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Catégories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/docker/">docker</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/php/">php</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/php扩展/">php扩展</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/regex/">regex</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/lnmp/" style="font-size: 15px;">lnmp</a> <a href="/tags/docker/" style="font-size: 15px;">docker</a> <a href="/tags/gdb/" style="font-size: 15px;">gdb</a> <a href="/tags/php/" style="font-size: 15px;">php</a> <a href="/tags/php扩展/" style="font-size: 15px;">php扩展</a> <a href="/tags/nginx/" style="font-size: 15px;">nginx</a> <a href="/tags/regex/" style="font-size: 15px;">regex</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/mysql/" style="font-size: 15px;">mysql</a> <a href="/tags/ipc/" style="font-size: 15px;">ipc</a> <a href="/tags/shell/" style="font-size: 15px;">shell</a> <a href="/tags/xdebug/" style="font-size: 15px;">xdebug</a> <a href="/tags/phpstorm/" style="font-size: 15px;">phpstorm</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Récent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/08/15/learn-regex-zh/">学习正则表达式的简单方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/15/php7-update/">PHP7 升级的那些事儿</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/10/php-ext-class/">PHP扩展实现类</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/23/debug-php-extension/">Debugging PHP Extensions</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/22/docker-basics/">docker常用命令</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/21/linux-ipc/">进程间通信（IPC）</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/21/nginx-cut-log/">nginx 直接在配置文件中切割日志</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/21/nginx-variables/">nginx 内置变量</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/21/linux-sort-uniq-cut-wc/">sort,uniq,cut,wc 命令详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/21/php-faq/">编译php常见问题</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">C &amp; Fish.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>